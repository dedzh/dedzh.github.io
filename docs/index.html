<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тетрис в браузере</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>ТЕТРИС</h1>
            <div class="subtitle">Классическая игра прямо в вашем браузере</div>
        </header>
        
        <div class="game-area">
            <div class="game-container">
                <div id="game-board"></div>
                
                <div class="side-panel">
                    <div class="panel-section">
                        <div class="panel-title">Счет</div>
                        <div id="score">0</div>
                        <div class="level-display">Уровень: <span id="level">1</span></div>
                    </div>
                    
                    <div class="panel-section">
                        <div class="panel-title">Следующая фигура</div>
                        <div class="next-piece" id="next-piece"></div>
                    </div>
                    
                    <div class="panel-section">
                        <div class="panel-title">Карман</div>
                        <div class="next-piece" id="hold-piece"></div>
                    </div>
                    
                    <div class="panel-section">
                        <div class="panel-title">Управление</div>
                        <div class="controls">
                            <button id="start-btn">Начать игру</button>
                            <button id="pause-btn">Пауза</button>
                            <button id="restart-btn">Заново</button>
                            <button id="rotate-btn">Повернуть</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h2>Как играть</h2>
            <div class="keyboard-controls">
                <div class="control-group">
                    <div class="control-item">
                        <span>Движение влево</span>
                        <div class="key">←</div>
                    </div>
                    <div class="control-item">
                        <span>Движение вправо</span>
                        <div class="key">→</div>
                    </div>
                    <div class="control-item">
                        <span>Ускоренное падение</span>
                        <div class="key">↓</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-item">
                        <span>Поворот фигуры</span>
                        <div class="key">↑</div>
                    </div>
                    <div class="control-item">
                        <span>Мгновенное падение</span>
                        <div class="key">Пробел</div>
                    </div>
                    <div class="control-item">
                        <span>Пауза</span>
                        <div class="key">P</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-item">
                        <span>Фигура в карман</span>
                        <div class="key">Tab</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="game-over" id="game-over">
            <h2>ИГРА ОКОНЧЕНА!</h2>
            <p>Ваш счет: <span id="final-score">0</span></p>
            <p>Максимальный уровень: <span id="final-level">1</span></p>
            <button id="play-again-btn">Играть снова</button>
        </div>
        
        <footer>
            <p>© 2025 Тетрис в браузере | Разработано с использованием HTML, CSS и JavaScript</p>
            <p>Игра размещена на GitHub Pages</p>
        </footer>
    </div>

    <script>
        /**
         * Классическая игра Тетрис
         * @module TetrisGame
         * @author [Ваше имя]
         * @version 1.0.0
         */

        /** Конфигурация игры */
        const CONFIG = {
            COLS: 10,           // Количество колонок на игровом поле
            ROWS: 20,           // Количество строк на игровом поле
            BLOCK_SIZE: 25,     // Размер блока в пикселях
            COLORS: [           // Цвета фигур
                '#000000',      // Пустая клетка
                '#FF0D72',      // I
                '#0DC2FF',      // J
                '#0DFF72',      // L
                '#F538FF',      // O
                '#FF8E0D',      // S
                '#FFE138',      // T
                '#3877FF'       // Z
            ],
            SHAPES: [           // Формы фигур
                [],             // Пустая фигура
                [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // I
                [[1,0,0], [1,1,1], [0,0,0]],                  // J
                [[0,0,1], [1,1,1], [0,0,0]],                  // L
                [[1,1], [1,1]],                               // O
                [[0,1,1], [1,1,0], [0,0,0]],                  // S
                [[0,1,0], [1,1,1], [0,0,0]],                  // T
                [[1,1,0], [0,1,1], [0,0,0]]                   // Z
            ],
            SCORE_VALUES: [    // Очки за очищенные линии
                0,      // 0 линий
                100,     // 1 линия
                300,     // 2 линии
                700,     // 3 линии
                1500     // 4 линии
            ],
            INITIAL_SPEED: 500, // Начальная скорость падения (мс)
            SPEED_STEP: 50      // Уменьшение скорости за уровень (мс)
        };

        /** Состояние игры */
        const gameState = {
            board: [],          // Игровое поле
            currentPiece: null, // Текущая фигура
            nextPiece: null,    // Следующая фигура
            holdPiece: null,    // Фигура в кармане
            canHold: true,      // Можно ли сейчас использовать карман
            score: 0,           // Текущий счет
            level: 1,          // Текущий уровень
            linesCleared: 0,    // Всего очищено линий
            gameOver: false,    // Игра завершена
            isPaused: false,    // Игра на паузе
            dropInterval: null, // Интервал падения
            dropSpeed: CONFIG.INITIAL_SPEED // Текущая скорость
        };

        /**
         * Инициализирует игровое поле
         * @function initBoard
         */
        function initBoard() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';
            
            gameState.board = Array.from({ length: CONFIG.ROWS }, () => Array(CONFIG.COLS).fill(0));
            
            for (let r = 0; r < CONFIG.ROWS; r++) {
                for (let c = 0; c < CONFIG.COLS; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${r}-${c}`;
                    gameBoard.appendChild(cell);
                }
            }
        }

        /**
         * Создает новую случайную фигуру
         * @function createPiece
         * @returns {Object} Новая фигура
         */
        function createPiece() {
            const pieceType = Math.floor(Math.random() * 7) + 1;
            return {
                type: pieceType,
                shape: CONFIG.SHAPES[pieceType],
                row: 0,
                col: Math.floor((CONFIG.COLS - CONFIG.SHAPES[pieceType][0].length) / 2),
                rotation: 0
            };
        }

        /**
         * Отрисовывает игровое поле и все элементы
         * @function drawBoard
         */
        function drawBoard() {
            // Очистка поля
            for (let r = 0; r < CONFIG.ROWS; r++) {
                for (let c = 0; c < CONFIG.COLS; c++) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    if (cell) {
                        cell.className = 'cell';
                        cell.style.backgroundColor = '';
                        cell.style.border = '';
                        cell.style.boxShadow = '';
                        
                        if (gameState.board[r][c]) {
                            cell.classList.add('filled');
                            cell.style.backgroundColor = CONFIG.COLORS[gameState.board[r][c]];
                        }
                    }
                }
            }
            
            // Отрисовка предпросмотра падения
            if (gameState.currentPiece && !gameState.gameOver) {
                const previewPiece = {...gameState.currentPiece};
                while (!checkCollision({...previewPiece, row: previewPiece.row + 1})) {
                    previewPiece.row++;
                }
                
                const previewShape = previewPiece.shape;
                for (let r = 0; r < previewShape.length; r++) {
                    for (let c = 0; c < previewShape[r].length; c++) {
                        if (previewShape[r][c]) {
                            const boardRow = previewPiece.row + r;
                            const boardCol = previewPiece.col + c;
                            
                            if (boardRow >= 0 && boardRow < CONFIG.ROWS && 
                                boardCol >= 0 && boardCol < CONFIG.COLS) {
                                const cell = document.getElementById(`cell-${boardRow}-${boardCol}`);
                                if (cell && !gameState.board[boardRow][boardCol]) {
                                    cell.classList.add('preview');
                                    cell.style.backgroundColor = CONFIG.COLORS[gameState.currentPiece.type];
                                }
                            }
                        }
                    }
                }
            }
            
            // Отрисовка текущей фигуры
            if (gameState.currentPiece && !gameState.gameOver) {
                const shape = gameState.currentPiece.shape;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const boardRow = gameState.currentPiece.row + r;
                            const boardCol = gameState.currentPiece.col + c;
                            
                            if (boardRow >= 0 && boardRow < CONFIG.ROWS && 
                                boardCol >= 0 && boardCol < CONFIG.COLS) {
                                const cell = document.getElementById(`cell-${boardRow}-${boardCol}`);
                                if (cell) {
                                    cell.classList.add('filled');
                                    cell.style.backgroundColor = CONFIG.COLORS[gameState.currentPiece.type];
                                }
                            }
                        }
                    }
                }
            }
            
            // Отрисовка следующей фигуры
            const nextPieceContainer = document.getElementById('next-piece');
            nextPieceContainer.innerHTML = '';
            
            if (gameState.nextPiece) {
                const shape = gameState.nextPiece.shape;
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        const cell = document.createElement('div');
                        cell.style.width = '20px';
                        cell.style.height = '20px';
                        cell.style.borderRadius = '3px';
                        
                        if (r < shape.length && c < shape[r].length && shape[r][c]) {
                            cell.style.backgroundColor = CONFIG.COLORS[gameState.nextPiece.type];
                            cell.style.border = `2px solid ${CONFIG.COLORS[0]}`;
                        } else {
                            cell.style.backgroundColor = 'transparent';
                        }
                        
                        nextPieceContainer.appendChild(cell);
                    }
                }
            }
            
            // Отрисовка фигуры в кармане
            const holdPieceContainer = document.getElementById('hold-piece');
            holdPieceContainer.innerHTML = '';
            
            if (gameState.holdPiece) {
                const shape = CONFIG.SHAPES[gameState.holdPiece.type];
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        const cell = document.createElement('div');
                        cell.style.width = '20px';
                        cell.style.height = '20px';
                        cell.style.borderRadius = '3px';
                        
                        if (r < shape.length && c < shape[r].length && shape[r][c]) {
                            cell.style.backgroundColor = CONFIG.COLORS[gameState.holdPiece.type];
                            cell.style.border = `2px solid ${CONFIG.COLORS[0]}`;
                        } else {
                            cell.style.backgroundColor = 'transparent';
                        }
                        
                        holdPieceContainer.appendChild(cell);
                    }
                }
            }
            
            // Обновление UI
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
        }

        /**
         * Проверяет столкновение фигуры с границами или другими фигурами
         * @function checkCollision
         * @param {Object} piece - Фигура для проверки
         * @returns {boolean} Есть ли столкновение
         */
        function checkCollision(piece) {
            const shape = piece.shape;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const newRow = piece.row + r;
                        const newCol = piece.col + c;
                        
                        if (
                            newCol < 0 || 
                            newCol >= CONFIG.COLS || 
                            newRow >= CONFIG.ROWS ||
                            (newRow >= 0 && gameState.board[newRow][newCol])
                        ) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        /**
         * Фиксирует текущую фигуру на игровом поле
         * @function lockPiece
         */
        function lockPiece() {
            const shape = gameState.currentPiece.shape;
            
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c]) {
                        const boardRow = gameState.currentPiece.row + r;
                        const boardCol = gameState.currentPiece.col + c;
                        
                        if (boardRow < 0) {
                            endGame();
                            return;
                        }
                        
                        gameState.board[boardRow][boardCol] = gameState.currentPiece.type;
                    }
                }
            }
            
            clearLines();
            
            gameState.currentPiece = gameState.nextPiece;
            gameState.nextPiece = createPiece();
            gameState.canHold = true;
            
            if (checkCollision(gameState.currentPiece)) {
                endGame();
            }
            
            drawBoard();
        }

        /**
         * Очищает заполненные линии и обновляет счет
         * @function clearLines
         */
        function clearLines() {
            let linesClearedThisTurn = 0;
            const linesToClear = [];
            
            for (let r = CONFIG.ROWS - 1; r >= 0; r--) {
                if (gameState.board[r].every(cell => cell !== 0)) {
                    linesToClear.push(r);
                    linesClearedThisTurn++;
                }
            }
            
            if (linesClearedThisTurn > 0) {
                linesToClear.forEach(r => {
                    for (let c = 0; c < CONFIG.COLS; c++) {
                        const cell = document.getElementById(`cell-${r}-${c}`);
                        if (cell) {
                            cell.style.backgroundColor = '#FFFFFF';
                        }
                    }
                });
                
                setTimeout(() => {
                    linesToClear.sort((a, b) => a - b);
                    linesToClear.forEach(r => {
                        for (let row = r; row > 0; row--) {
                            gameState.board[row] = [...gameState.board[row - 1]];
                        }
                        gameState.board[0] = Array(CONFIG.COLS).fill(0);
                    });
                    
                    gameState.linesCleared += linesClearedThisTurn;
                    gameState.score += CONFIG.SCORE_VALUES[linesClearedThisTurn] || 0;
                    
                    const newLevel = Math.floor(gameState.linesCleared / 10) + 1;
                    if (newLevel > gameState.level) {
                        gameState.level = newLevel;
                        gameState.dropSpeed = Math.max(
                            100, 
                            CONFIG.INITIAL_SPEED - (gameState.level - 1) * CONFIG.SPEED_STEP
                        );
                        
                        if (gameState.dropInterval) {
                            clearInterval(gameState.dropInterval);
                            gameState.dropInterval = setInterval(gameLoop, gameState.dropSpeed);
                        }
                    }
                    
                    drawBoard();
                }, 300);
            }
        }

        /**
         * Перемещает текущую фигуру
         * @function movePiece
         * @param {number} dRow - Изменение по вертикали
         * @param {number} dCol - Изменение по горизонтали
         * @returns {boolean} Удалось ли переместить
         */
        function movePiece(dRow, dCol) {
            if (gameState.gameOver || gameState.isPaused) return false;
            
            const testPiece = {
                ...gameState.currentPiece,
                row: gameState.currentPiece.row + dRow,
                col: gameState.currentPiece.col + dCol
            };
            
            if (!checkCollision(testPiece)) {
                gameState.currentPiece.row = testPiece.row;
                gameState.currentPiece.col = testPiece.col;
                drawBoard();
                return true;
            } 
            else if (dRow > 0) {
                lockPiece();
                return false;
            }
            
            return false;
        }

        /**
         * Вращает текущую фигуру
         * @function rotatePiece
         */
        function rotatePiece() {
            if (gameState.gameOver || gameState.isPaused) return;
            
            const originalShape = [...gameState.currentPiece.shape.map(row => [...row])];
            const originalRotation = gameState.currentPiece.rotation;
            
            gameState.currentPiece.rotation = (gameState.currentPiece.rotation + 1) % 4;
            const rows = originalShape.length;
            const cols = originalShape[0].length;
            
            const rotated = Array.from({ length: cols }, () => Array(rows).fill(0));
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    rotated[c][rows - 1 - r] = originalShape[r][c];
                }
            }
            
            gameState.currentPiece.shape = rotated;
            
            if (checkCollision(gameState.currentPiece)) {
                gameState.currentPiece.rotation = originalRotation;
                gameState.currentPiece.shape = originalShape;
            }
            
            drawBoard();
        }

        /**
         * Мгновенно опускает фигуру вниз
         * @function dropPiece
         */
        function dropPiece() {
            if (gameState.gameOver || gameState.isPaused) return;
            
            while (movePiece(1, 0)) {
                gameState.score += 2;
            }
        }

        /**
         * Помещает текущую фигуру в карман
         * @function holdCurrentPiece
         */
        function holdCurrentPiece() {
            if (!gameState.canHold || gameState.gameOver || gameState.isPaused) return;
            
            if (gameState.holdPiece === null) {
                gameState.holdPiece = {
                    type: gameState.currentPiece.type,
                    shape: CONFIG.SHAPES[gameState.currentPiece.type],
                    rotation: 0
                };
                gameState.currentPiece = gameState.nextPiece;
                gameState.nextPiece = createPiece();
            } else {
                const tempType = gameState.currentPiece.type;
                gameState.currentPiece.type = gameState.holdPiece.type;
                gameState.currentPiece.shape = CONFIG.SHAPES[gameState.holdPiece.type];
                gameState.currentPiece.rotation = 0;
                gameState.currentPiece.col = Math.floor(
                    (CONFIG.COLS - gameState.currentPiece.shape[0].length) / 2
                );
                gameState.currentPiece.row = 0;
                
                gameState.holdPiece.type = tempType;
                gameState.holdPiece.shape = CONFIG.SHAPES[tempType];
            }
            
            gameState.currentPiece.col = Math.floor(
                (CONFIG.COLS - gameState.currentPiece.shape[0].length) / 2
            );
            gameState.currentPiece.row = 0;
            
            if (checkCollision(gameState.currentPiece)) {
                endGame();
            }
            
            gameState.canHold = false;
            drawBoard();
        }

        /**
         * Основной игровой цикл
         * @function gameLoop
         */
        function gameLoop() {
            if (gameState.gameOver || gameState.isPaused) return;
            movePiece(1, 0);
        }

        /**
         * Завершает игру
         * @function endGame
         */
        function endGame() {
            gameState.gameOver = true;
            clearInterval(gameState.dropInterval);
            
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('final-level').textContent = gameState.level;
            document.getElementById('game-over').style.display = 'block';
        }

        /**
         * Инициализирует новую игру
         * @function initGame
         */
        function initGame() {
            initBoard();
            gameState.score = 0;
            gameState.level = 1;
            gameState.linesCleared = 0;
            gameState.gameOver = false;
            gameState.isPaused = false;
            gameState.dropSpeed = CONFIG.INITIAL_SPEED;
            gameState.holdPiece = null;
            gameState.canHold = true;
            
            gameState.currentPiece = createPiece();
            gameState.nextPiece = createPiece();
            
            drawBoard();
            
            if (gameState.dropInterval) clearInterval(gameState.dropInterval);
            gameState.dropInterval = setInterval(gameLoop, gameState.dropSpeed);
            
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('pause-btn').textContent = 'Пауза';
        }

        /**
         * Переключает состояние паузы
         * @function togglePause
         */
        function togglePause() {
            if (gameState.gameOver) return;
            
            gameState.isPaused = !gameState.isPaused;
            document.getElementById('pause-btn').textContent = 
                gameState.isPaused ? 'Продолжить' : 'Пауза';
                
            if (gameState.isPaused) {
                clearInterval(gameState.dropInterval);
            } else {
                gameState.dropInterval = setInterval(gameLoop, gameState.dropSpeed);
            }
        }

        // Обработчики событий
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver && e.key !== 'Enter') return;
            
            switch (e.key) {
                case 'ArrowLeft': movePiece(0, -1); break;
                case 'ArrowRight': movePiece(0, 1); break;
                case 'ArrowDown': movePiece(1, 0); break;
                case 'ArrowUp': rotatePiece(); break;
                case ' ': dropPiece(); break;
                case 'p':
                case 'P': togglePause(); break;
                case 'Tab': e.preventDefault(); holdCurrentPiece(); break;
                case 'Enter': if (gameState.gameOver) initGame(); break;
            }
        });

        document.getElementById('start-btn').addEventListener('click', initGame);
        document.getElementById('play-again-btn').addEventListener('click', initGame);
        document.getElementById('restart-btn').addEventListener('click', initGame);
        document.getElementById('rotate-btn').addEventListener('click', rotatePiece);
        document.getElementById('pause-btn').addEventListener('click', togglePause);

        // Запуск игры
        window.onload = initGame;
    </script>
</body>
</html>